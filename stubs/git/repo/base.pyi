from collections import namedtuple
from typing import Any, Optional

BlameEntry = namedtuple('BlameEntry', ['commit', 'linenos', 'orig_path', 'orig_linenos'])

class Repo:
    DAEMON_EXPORT_FILE: str = ...
    git: Any = ...
    working_dir: Any = ...
    git_dir: Any = ...
    re_whitespace: Any = ...
    re_hexsha_only: Any = ...
    re_hexsha_shortened: Any = ...
    re_envvars: Any = ...
    re_author_committer_start: Any = ...
    re_tab_full_line: Any = ...
    config_level: Any = ...
    GitCommandWrapperType: Any = ...
    odb: Any = ...
    def __init__(self, path: Optional[Any] = ..., odbt: Any = ..., search_parent_directories: bool = ..., expand_vars: bool = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def __eq__(self, rhs: Any) -> Any: ...
    def __ne__(self, rhs: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    description: Any = ...
    @property
    def working_tree_dir(self): ...
    @property
    def common_dir(self): ...
    @property
    def bare(self): ...
    @property
    def heads(self): ...
    @property
    def references(self): ...
    refs: Any = ...
    branches: Any = ...
    @property
    def index(self): ...
    @property
    def head(self): ...
    @property
    def remotes(self): ...
    def remote(self, name: str = ...): ...
    @property
    def submodules(self): ...
    def submodule(self, name: Any): ...
    def create_submodule(self, *args: Any, **kwargs: Any): ...
    def iter_submodules(self, *args: Any, **kwargs: Any): ...
    def submodule_update(self, *args: Any, **kwargs: Any): ...
    @property
    def tags(self): ...
    def tag(self, path: Any): ...
    def create_head(self, path: Any, commit: str = ..., force: bool = ..., logmsg: Optional[Any] = ...): ...
    def delete_head(self, *heads: Any, **kwargs: Any): ...
    def create_tag(self, path: Any, ref: str = ..., message: Optional[Any] = ..., force: bool = ..., **kwargs: Any): ...
    def delete_tag(self, *tags: Any): ...
    def create_remote(self, name: Any, url: Any, **kwargs: Any): ...
    def delete_remote(self, remote: Any): ...
    def config_reader(self, config_level: Optional[Any] = ...): ...
    def config_writer(self, config_level: str = ...): ...
    def commit(self, rev: Optional[Any] = ...): ...
    def iter_trees(self, *args: Any, **kwargs: Any): ...
    def tree(self, rev: Optional[Any] = ...): ...
    def iter_commits(self, rev: Optional[Any] = ..., paths: str = ..., **kwargs: Any): ...
    def merge_base(self, *rev: Any, **kwargs: Any): ...
    def is_ancestor(self, ancestor_rev: Any, rev: Any): ...
    daemon_export: Any = ...
    alternates: Any = ...
    def is_dirty(self, index: bool = ..., working_tree: bool = ..., untracked_files: bool = ..., submodules: bool = ..., path: Optional[Any] = ...): ...
    @property
    def untracked_files(self): ...
    def ignored(self, *paths: Any): ...
    @property
    def active_branch(self): ...
    def blame_incremental(self, rev: Any, file: Any, **kwargs: Any) -> None: ...
    def blame(self, rev: Any, file: Any, incremental: bool = ..., **kwargs: Any): ...
    @classmethod
    def init(cls, path: Optional[Any] = ..., mkdir: bool = ..., odbt: Any = ..., expand_vars: bool = ..., **kwargs: Any): ...
    def clone(self, path: Any, progress: Optional[Any] = ..., multi_options: Optional[Any] = ..., **kwargs: Any): ...
    @classmethod
    def clone_from(cls, url: Any, to_path: Any, progress: Optional[Any] = ..., env: Optional[Any] = ..., multi_options: Optional[Any] = ..., **kwargs: Any): ...
    def archive(self, ostream: Any, treeish: Optional[Any] = ..., prefix: Optional[Any] = ..., **kwargs: Any): ...
    def has_separate_working_tree(self): ...
    rev_parse: Any = ...
    def currently_rebasing_on(self): ...
